# Render-tree Construction, Layout, and Paint

**목차**

- [Render-tree Construction, Layout, and Paint](#render-tree-construction-layout-and-paint)
  - [개요](#개요)
  - [Summary](#summary)

## 개요

**CSSOM 트리**와 **DOM 트리**는 Render 트리로 결합되어 보이는 각 요소의 레이아웃을 계산하는 데 사용되며 픽셀을 화면에 렌더링하는 페인트 프로세스의 입력으로 사용됩니다. 이러한 각 단계를 최적화하는 것은 최적의 렌더링 성능을 달성하는 데 매우 중요합니다.

객체 모델 구성에 대해 이전 섹션에서는 **HTML**과 **CSS** 입력을 기반으로 **DOM**과 **CSSOM** 트리를 구축했습니다. 그러나 이 두 객체는 문서의 서로 다른 측면을 캡처하는 독립적인 객체로, 하나는 콘텐츠를 설명하고 다른 하나는 문서에 적용해야 하는 스타일 규칙을 설명합니다. 이 두 가지를 병합하여 브라우저가 화면에 픽셀을 렌더링하도록 하려면 어떻게 해야 할까요?

## Summary

- **DOM 트리**와 **CSSOM 트리**가 결합되어 **Render 트리**를 형성합니다.
- **Render 트리**에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.
- **Layout**은 각 개체의 정확한 위치와 크기를 계산합니다.
- 마지막 단계는 최종 렌더 트리를 가져와 화면에 픽셀을 렌더링하는 **Paint** 단계입니다.

먼저 브라우저는 페이지에 표시되는 모든 **DOM** 콘텐츠와 각 노드에 대한 모든 **CSSOM** 스타일 정보를 캡처하는 "**Render 트리**"로 **DOM**과 **CSSOM**을 결합합니다.

<img src="images/1.avif" alt="DOM, CSSOM 그리고 Render 트리" width="600" />

**Render 트리**를 구성하기 위해 브라우저는 대략 다음과 같은 작업을 수행합니다:

1. **DOM 트리**의 루트에서 시작하여 보이는 각 노드를 순회합니다.
   - 일부 노드(예: `script` 태그, `meta` 태그 등)는 표시되지 않으며 렌더링된 출력에 반영되지 않으므로 생략됩니다.
   - 예를 들어, 위 예시에서 `span` 노드는 `display: none` 속성을 설정하는 명시적 규칙이 있기 때문에 **Render 트리**에서 누락되어 있습니다.
2. 표시되는 각 노드에 대해 적절하게 일치하는 **CSSOM** 규칙을 찾아서 적용합니다.
3. Emit visible nodes with content and their computed styles.

> 참고로, `visibility: hidden`은 `display: none`과 다르다는 점에 유의하세요. 전자는 요소를 보이지 않게 만들지만 요소가 여전히 레이아웃에서 공간을 차지하는 반면(즉, 빈 상자로 렌더링됨), 후자(`display: none`)는 **Render 트리**에서 요소를 완전히 제거하여 요소가 보이지 않고 레이아웃의 일부가 되지 않도록 합니다.

최종 출력은 화면에 표시되는 모든 콘텐츠의 콘텐츠 및 스타일 정보를 모두 포함하는 **Render 트리**입니다. **Render 트리**가 제자리에 있으면 "**Layout**" 단계로 넘어갈 수 있습니다.

지금까지 표시할 노드와 계산된 스타일을 계산했지만 기기 뷰포트 내에서 정확한 위치와 크기를 계산하지는 않았는데, 이것이 바로 "**Reflow**"라고도 하는 "**Layout**" 단계입니다.

페이지에서 각 객체의 정확한 크기와 위치를 파악하기 위해 브라우저는 **Render 트리**의 루트에서 시작하여 이를 순회합니다. 간단한 실습 예제를 살펴보겠습니다:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Critial Path: Hello world!</title>
  </head>
  <body>
    <div style="width: 50%">
      <div style="width: 50%">Hello world!</div>
    </div>
  </body>
</html>
```

위 페이지 본문에는 두 개의 중첩된 `div`가 포함되어 있습니다. 첫 번째(부모) `div`는 노드의 표시 크기를 뷰포트 너비의 50%로 설정하고, 부모가 포함하는 두 번째 `div`는 너비를 부모의 50%, 즉 뷰포트 너비의 25%로 설정합니다.

<img src="images/2.avif" alt="실습 예제" width="600" />

**Layout** 프로세스의 출력은 뷰포트 내에서 각 요소의 정확한 위치와 크기를 정확하게 캡처하는 "박스(box) 모델"로, 모든 상대 측정값은 화면에서 절대 픽셀로 변환됩니다.

마지막으로 어떤 노드가 표시되는지, 계산된 스타일과 위치 정보가 무엇인지 알았으므로 이 정보를 **Render 트리**의 각 노드를 화면의 실제 픽셀로 변환하는 최종 단계로 전달할 수 있습니다. 이 단계를 흔히 "**Painting**" 또는 "**Rasterizing**"라고 합니다.

브라우저에서 상당한 작업을 수행해야 하므로 시간이 다소 걸릴 수 있습니다. 하지만 크롬 개발자도구는 위에서 설명한 세 단계 모두에 대한 인사이트를 제공할 수 있습니다. 원래 예제인 "**헬로 월드**"의 레이아웃 단계를 살펴봅시다:

<img src="images/3.avif" alt="hello world 실습 예제에 대한 개발자 도구" width="600" />

- "**Layout**" 이벤트는 타임라인에서 렌더링 트리 구성, 위치 및 크기 계산을 캡처합니다.
- Layout이 완료되면 브라우저는 렌더링 트리를 화면의 픽셀로 변환하는 "**Paint Setup**" 및 "**Paint**" 이벤트를 발생시킵니다.

**Render 트리** 구성, 레이아웃 및 페인팅을 수행하는 데 필요한 시간은 문서의 크기, 적용된 스타일 및 실행 중인 기기에 따라 달라집니다. 문서가 클수록 브라우저의 작업량이 많아지고 스타일이 복잡할수록 페인팅에도 더 많은 시간이 소요됩니다(예: 단색은 페인팅에 "저렴한" 반면 그림자 효과는 계산 및 렌더링에 "많은" 시간이 소요됩니다).

페이지가 마침내 뷰포트에 표시됩니다:

<img src="images/4.avif" alt="기기에서 보여지는 예시" width="600" />

다음은 브라우저의 단계를 간단히 요약한 것입니다:

1. **HTML** 마크업을 처리하고 **DOM 트리**를 빌드합니다.
2. **CSS** 마크업을 처리하고 **CSSOM 트리**를 작성합니다.
3. **DOM**과 **CSSOM**을 **Render 트리**로 결합합니다.
4. **Render 트리**에서 레이아웃을 실행하여 각 노드의 위치 정보를 계산합니다.
5. 개별 노드를 화면에 칠합니다(Paint).

데모 페이지는 간단해 보이지만 꽤 많은 작업이 필요합니다. **DOM** 또는 **CSSOM**이 수정된 경우 화면에서 어떤 픽셀을 다시 렌더링해야 하는지 파악하기 위해 이 과정을 반복해야 합니다.

**중요 렌더링 경로를 최적화하는 것은 위의 순서에서 1~5단계를 수행하는 데 소요되는 총 시간을 최소화하는 프로세스입니다**. 이렇게 하면 콘텐츠를 최대한 빠르게 화면에 렌더링하고 초기 렌더링 후 화면 업데이트 사이의 시간, 즉 인터랙티브 콘텐츠의 새로 고침 빈도를 줄일 수 있습니다.
